diff --git a/src/algorithm/mod.rs b/src/algorithm/mod.rs
index 7ae240a8..35dad3d1 100644
--- a/src/algorithm/mod.rs
+++ b/src/algorithm/mod.rs
@@ -3,7 +3,7 @@ extern crate libc;
 use array::Array;
 use defines::{AfError, BinaryOp};
 use error::HANDLE_ERROR;
-use self::libc::{c_int, uint8_t, c_uint, c_double};
+use self::libc::{c_int, c_uint, c_double};
 use util::{AfArray, MutAfArray, MutDouble, MutUint};
 use util::{HasAfEnum, Scanable, RealNumber};
 
@@ -44,9 +44,9 @@ extern {
     fn af_sort_by_key(out_keys: MutAfArray, out_vals: MutAfArray,
                       in_keys: AfArray, in_vals: AfArray, dim: c_uint, ascend: c_int) -> c_int;
 
-    fn af_scan(out: MutAfArray, inp: AfArray, dim: c_int, op: uint8_t, inclusive: c_int) -> c_int;
+    fn af_scan(out: MutAfArray, inp: AfArray, dim: c_int, op: c_uint, inclusive: c_int) -> c_int;
     fn af_scan_by_key(out: MutAfArray, key: AfArray, inp: AfArray,
-                      dim: c_int, op: uint8_t, inclusive: c_int) -> c_int;
+                      dim: c_int, op: c_uint, inclusive: c_int) -> c_int;
 }
 
 macro_rules! dim_reduce_func_def {
@@ -922,7 +922,7 @@ pub fn scan<T>(input: &Array<T>, dim: i32,
     let mut temp : i64 = 0;
     unsafe {
         let err_val = af_scan(&mut temp as MutAfArray, input.get() as AfArray,
-                              dim as c_int, op as uint8_t, inclusive as c_int);
+                              dim as c_int, op as c_uint, inclusive as c_int);
         HANDLE_ERROR(AfError::from(err_val));
     }
     temp.into()
@@ -953,7 +953,7 @@ pub fn scan_by_key<K, V>(key: &Array<K>, input: &Array<V>,
     unsafe {
         let err_val = af_scan_by_key(&mut temp as MutAfArray, key.get() as AfArray,
                                      input.get() as AfArray, dim as c_int,
-                                     op as uint8_t, inclusive as c_int);
+                                     op as c_uint, inclusive as c_int);
         HANDLE_ERROR(AfError::from(err_val));
     }
     temp.into()
diff --git a/src/array.rs b/src/array.rs
index 00bd5240..bc94c7ae 100644
--- a/src/array.rs
+++ b/src/array.rs
@@ -4,7 +4,7 @@ use dim4::Dim4;
 use defines::{AfError, DType, Backend};
 use error::HANDLE_ERROR;
 use util::{AfArray, DimT, HasAfEnum, MutAfArray, MutVoidPtr};
-use self::libc::{uint8_t, c_void, c_int, c_uint, c_longlong, c_char};
+use self::libc::{c_void, c_int, c_uint, c_longlong, c_char};
 use std::marker::PhantomData;
 use std::ffi::CString;
 
@@ -16,13 +16,13 @@ use std::ffi::CString;
 #[allow(dead_code)]
 extern {
     fn af_create_array(out: MutAfArray, data: *const c_void,
-                       ndims: c_uint, dims: *const DimT, aftype: uint8_t) -> c_int;
+                       ndims: c_uint, dims: *const DimT, aftype: c_uint) -> c_int;
 
-    fn af_create_handle(out: MutAfArray, ndims: c_uint, dims: *const DimT, aftype: uint8_t) -> c_int;
+    fn af_create_handle(out: MutAfArray, ndims: c_uint, dims: *const DimT, aftype: c_uint) -> c_int;
 
     fn af_get_elements(out: MutAfArray, arr: AfArray) -> c_int;
 
-    fn af_get_type(out: *mut c_int, arr: AfArray) -> c_int;
+    fn af_get_type(out: *mut c_uint, arr: AfArray) -> c_int;
 
     fn af_get_dims(dim0: *mut c_longlong, dim1: *mut c_longlong, dim2: *mut c_longlong,
                    dim3: *mut c_longlong, arr: AfArray) -> c_int;
@@ -75,15 +75,15 @@ extern {
 
     fn af_print_array_gen(exp: *const c_char, arr: AfArray, precision: c_int) -> c_int;
 
-    fn af_cast(out: MutAfArray, arr: AfArray, aftype: uint8_t) -> c_int;
+    fn af_cast(out: MutAfArray, arr: AfArray, aftype: c_uint) -> c_int;
 
-    fn af_get_backend_id(backend: *mut c_int, input: AfArray) -> c_int;
+    fn af_get_backend_id(backend: *mut c_uint, input: AfArray) -> c_int;
 
     fn af_get_device_id(device: *mut c_int, input: AfArray) -> c_int;
 
     fn af_create_strided_array(arr: MutAfArray, data: *const c_void, offset: DimT,
                                ndims: c_uint, dims: *const DimT, strides: *const DimT,
-                               aftype: uint8_t, stype: uint8_t) -> c_int;
+                               aftype: c_uint, stype: c_uint) -> c_int;
 
     fn af_get_strides(s0: *mut DimT, s1: *mut DimT, s2: *mut DimT, s3: *mut DimT,
                       arr: AfArray) -> c_int;
@@ -155,7 +155,7 @@ impl<T> Array<T> where T: HasAfEnum {
                                           slice.as_ptr() as *const c_void,
                                           dims.ndims() as c_uint,
                                           dims.get().as_ptr() as * const c_longlong,
-                                          aftype as uint8_t);
+                                          aftype as c_uint);
             HANDLE_ERROR(AfError::from(err_val));
         }
         temp.into()
@@ -176,7 +176,7 @@ impl<T> Array<T> where T: HasAfEnum {
                                                   dims.ndims() as c_uint,
                                                   dims.get().as_ptr() as * const c_longlong,
                                                   strides.get().as_ptr() as * const c_longlong,
-                                                  aftype as uint8_t, 1);
+                                                  aftype as c_uint, 1 as c_uint);
             HANDLE_ERROR(AfError::from(err_val));
         }
         temp.into()
@@ -198,7 +198,7 @@ impl<T> Array<T> where T: HasAfEnum {
             let err_val = af_create_handle(&mut temp as MutAfArray,
                                            dims.ndims() as c_uint,
                                            dims.get().as_ptr() as * const c_longlong,
-                                           aftype as uint8_t);
+                                           aftype as c_uint);
             HANDLE_ERROR(AfError::from(err_val));
             temp.into()
         }
@@ -212,8 +212,8 @@ impl<T> Array<T> where T: HasAfEnum {
     /// was active when Array was created.
     pub fn get_backend(&self) -> Backend {
         unsafe {
-            let mut ret_val: i32 = 0;
-            let err_val = af_get_backend_id(&mut ret_val as *mut c_int, self.handle as AfArray);
+            let mut ret_val: u32 = 0;
+            let err_val = af_get_backend_id(&mut ret_val as *mut c_uint, self.handle as AfArray);
             HANDLE_ERROR(AfError::from(err_val));
             match (err_val, ret_val) {
                 (0, 1) => Backend::CPU,
@@ -251,8 +251,8 @@ impl<T> Array<T> where T: HasAfEnum {
     /// Returns the Array data type
     pub fn get_type(&self) -> DType {
         unsafe {
-            let mut ret_val: i32 = 0;
-            let err_val = af_get_type(&mut ret_val as *mut c_int, self.handle as AfArray);
+            let mut ret_val: u32 = 0;
+            let err_val = af_get_type(&mut ret_val as *mut c_uint, self.handle as AfArray);
             HANDLE_ERROR(AfError::from(err_val));
             DType::from(ret_val)
         }
@@ -364,7 +364,7 @@ impl<T> Array<T> where T: HasAfEnum {
         let trgt_type = O::get_af_dtype();
         let mut temp: i64 = 0;
         unsafe {
-            let err_val = af_cast(&mut temp as MutAfArray, self.handle as AfArray, trgt_type as uint8_t);
+            let err_val = af_cast(&mut temp as MutAfArray, self.handle as AfArray, trgt_type as c_uint);
             HANDLE_ERROR(AfError::from(err_val));
         }
         temp.into()
diff --git a/src/data/mod.rs b/src/data/mod.rs
index d0bc8c42..0d266c5d 100644
--- a/src/data/mod.rs
+++ b/src/data/mod.rs
@@ -5,7 +5,7 @@ use array::Array;
 use dim4::Dim4;
 use defines::{AfError};
 use error::HANDLE_ERROR;
-use self::libc::{uint8_t, c_int, c_uint, c_double};
+use self::libc::{c_int, c_uint, c_double};
 use self::num::Complex;
 use util::{AfArray, DimT, HasAfEnum, Intl, MutAfArray, Uintl};
 use std::vec::Vec;
@@ -25,12 +25,12 @@ extern {
                          ndims: c_uint, dims: *const DimT) -> c_int;
 
     fn af_range(out: MutAfArray, ndims: c_uint, dims: *const DimT,
-                seq_dims: c_int, afdtype: uint8_t) -> c_int;
+                seq_dims: c_int, afdtype: c_uint) -> c_int;
 
     fn af_iota(out: MutAfArray, ndims: c_uint, dims: *const DimT,
-               t_ndims: c_uint, tdims: *const DimT, afdtype: uint8_t) -> c_int;
+               t_ndims: c_uint, tdims: *const DimT, afdtype: c_uint) -> c_int;
 
-    fn af_identity(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: uint8_t) -> c_int;
+    fn af_identity(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: c_uint) -> c_int;
     fn af_diag_create(out: MutAfArray, arr: AfArray, num: c_int) -> c_int;
     fn af_diag_extract(out: MutAfArray, arr: AfArray, num: c_int) -> c_int;
     fn af_join(out: MutAfArray, dim: c_int, first: AfArray, second: AfArray) -> c_int;
@@ -243,7 +243,7 @@ pub fn range<T: HasAfEnum>(dims: Dim4, seq_dim: i32) -> Array<T> {
     unsafe {
         let err_val = af_range(&mut temp as MutAfArray,
                               dims.ndims() as c_uint, dims.get().as_ptr() as *const DimT,
-                              seq_dim as c_int, aftype as uint8_t);
+                              seq_dim as c_int, aftype as c_uint);
         HANDLE_ERROR(AfError::from(err_val));
     }
     temp.into()
@@ -269,7 +269,7 @@ pub fn iota<T: HasAfEnum>(dims: Dim4, tdims: Dim4) -> Array<T> {
         let err_val =af_iota(&mut temp as MutAfArray,
                              dims.ndims() as c_uint, dims.get().as_ptr() as *const DimT,
                              tdims.ndims() as c_uint, tdims.get().as_ptr() as *const DimT,
-                             aftype as uint8_t);
+                             aftype as c_uint);
         HANDLE_ERROR(AfError::from(err_val));
     }
     temp.into()
@@ -291,7 +291,7 @@ pub fn identity<T: HasAfEnum>(dims: Dim4) -> Array<T> {
     unsafe {
         let err_val = af_identity(&mut temp as MutAfArray,
                                   dims.ndims() as c_uint, dims.get().as_ptr() as *const DimT,
-                                  aftype as uint8_t);
+                                  aftype as c_uint);
         HANDLE_ERROR(AfError::from(err_val));
     }
     temp.into()
diff --git a/src/defines.rs b/src/defines.rs
index 26531a4d..969b0af5 100644
--- a/src/defines.rs
+++ b/src/defines.rs
@@ -6,7 +6,7 @@ use std::fmt::Error as FmtError;
 use self::num::Complex;
 
 /// Error codes
-#[repr(C)]
+#[repr(i32)]
 #[derive(Clone, Copy, Debug, PartialEq)]
 pub enum AfError {
     /// The function returned successfully
@@ -53,7 +53,7 @@ pub enum AfError {
 }
 
 /// Compute/Acceleration Backend
-#[repr(C)]
+#[repr(u32)]
 #[derive(Clone, Copy, Debug, PartialEq)]
 pub enum Backend {
     /// Default backend order: OpenCL -> CUDA -> CPU
@@ -109,7 +109,7 @@ impl Error for AfError {
 }
 
 /// Types of Array data type
-#[repr(C)]
+#[repr(u32)]
 #[derive(Clone, Copy, Debug, PartialEq)]
 pub enum DType {
     /// 32 bit float
@@ -139,7 +139,7 @@ pub enum DType {
 }
 
 /// Dictates the interpolation method to be used by a function
-#[repr(C)]
+#[repr(u32)]
 #[derive(Clone, Copy, Debug, PartialEq)]
 pub enum InterpType {
     /// Nearest Neighbor interpolation method
@@ -165,7 +165,7 @@ pub enum InterpType {
 }
 
 /// Helps determine how to pad kernels along borders
-#[repr(C)]
+#[repr(u32)]
 #[derive(Clone, Copy, Debug, PartialEq)]
 pub enum BorderType {
     /// Pad using zeros
@@ -175,7 +175,7 @@ pub enum BorderType {
 }
 
 /// Used by `regions` function to identify type of connectivity
-#[repr(C)]
+#[repr(u32)]
 #[derive(Clone, Copy, Debug, PartialEq)]
 pub enum Connectivity {
     /// North-East-South-West (N-E-S-W) connectivity from given pixel/point
@@ -185,7 +185,7 @@ pub enum Connectivity {
 }
 
 /// Helps determine the size of output of convolution
-#[repr(C)]
+#[repr(u32)]
 #[derive(Clone, Copy, Debug, PartialEq)]
 pub enum ConvMode {
     /// Default convolution mode where output size is same as input size
@@ -195,7 +195,7 @@ pub enum ConvMode {
 }
 
 /// Helps determine if convolution is in Spatial or Frequency domain
-#[repr(C)]
+#[repr(u32)]
 #[derive(Clone, Copy, Debug, PartialEq)]
 pub enum ConvDomain {
     /// ArrayFire chooses whether the convolution will be in spatial domain or frequency domain
@@ -207,7 +207,7 @@ pub enum ConvDomain {
 }
 
 /// Error metric used by `matchTemplate` function
-#[repr(C)]
+#[repr(u32)]
 #[derive(Clone, Copy, Debug, PartialEq)]
 pub enum MatchType {
     /// Sum of Absolute Differences
@@ -231,7 +231,7 @@ pub enum MatchType {
 }
 
 /// Identify the color space of given image(Array)
-#[repr(C)]
+#[repr(u32)]
 #[derive(Clone, Copy, Debug, PartialEq)]
 pub enum ColorSpace {
     /// Grayscale color space
@@ -243,7 +243,7 @@ pub enum ColorSpace {
 }
 
 /// Helps determine the type of a Matrix
-#[repr(C)]
+#[repr(u32)]
 #[derive(Clone, Copy, Debug, PartialEq)]
 pub enum MatProp {
     /// Default (no-op)
@@ -272,7 +272,7 @@ pub enum MatProp {
 
 /// Norm type
 #[allow(non_camel_case_types)]
-#[repr(C)]
+#[repr(u32)]
 #[derive(Clone, Copy, Debug, PartialEq)]
 pub enum NormType {
     /// Treats input as a vector and return sum of absolute values
@@ -294,7 +294,7 @@ pub enum NormType {
 }
 
 /// Dictates what color map is used for Image rendering
-#[repr(C)]
+#[repr(u32)]
 #[derive(Clone, Copy, Debug, PartialEq)]
 pub enum ColorMap {
     /// Default color map is grayscale range [0-1]
@@ -314,7 +314,7 @@ pub enum ColorMap {
 }
 
 /// YCbCr Standards
-#[repr(C)]
+#[repr(u32)]
 #[derive(Clone, Copy, Debug, PartialEq)]
 pub enum YCCStd {
     /// ITU-R BT.601 (formerly CCIR 601) standard
@@ -326,7 +326,7 @@ pub enum YCCStd {
 }
 
 /// Homography type
-#[repr(C)]
+#[repr(u32)]
 #[derive(Clone, Copy, Debug, PartialEq)]
 pub enum HomographyType {
     /// RANdom SAmple Consensus algorithm
@@ -336,7 +336,7 @@ pub enum HomographyType {
 }
 
 /// Plotting markers
-#[repr(C)]
+#[repr(u32)]
 #[derive(Clone, Copy, Debug, PartialEq)]
 pub enum MarkerType {
     /// No marker
@@ -358,7 +358,7 @@ pub enum MarkerType {
 }
 
 /// Image moment types
-#[repr(C)]
+#[repr(u32)]
 #[derive(Clone, Copy, Debug, PartialEq)]
 pub enum MomentType {
     /// Central moment of order (0 + 0)
@@ -374,7 +374,7 @@ pub enum MomentType {
 }
 
 /// Sparse storage format type
-#[repr(C)]
+#[repr(u32)]
 #[derive(Clone, Copy, Debug, PartialEq)]
 pub enum SparseFormat {
     /// Dense format
@@ -388,7 +388,7 @@ pub enum SparseFormat {
 }
 
 /// Binary operation types for generalized scan functions
-#[repr(C)]
+#[repr(u32)]
 #[derive(Clone, Copy, Debug, PartialEq)]
 pub enum BinaryOp {
     /// Addition operation
@@ -402,7 +402,7 @@ pub enum BinaryOp {
 }
 
 /// Random engine types
-#[repr(C)]
+#[repr(u32)]
 #[derive(Clone, Copy, Debug, PartialEq)]
 pub enum RandomEngineType {
     ///Philox variant with N=4, W=32 and Rounds=10
@@ -452,7 +452,7 @@ pub enum Scalar {
 }
 
 /// Canny edge detector threshold operations types
-#[repr(C)]
+#[repr(u32)]
 #[derive(Clone, Copy, Debug, PartialEq)]
 pub enum CannyThresholdType {
     /// User has to define canny thresholds manually
@@ -462,7 +462,7 @@ pub enum CannyThresholdType {
 }
 
 /// Anisotropic diffusion flux equation types
-#[repr(C)]
+#[repr(u32)]
 #[derive(Clone, Copy, Debug, PartialEq)]
 pub enum DiffusionEq {
     /// Quadratic flux function
@@ -474,7 +474,7 @@ pub enum DiffusionEq {
 }
 
 /// Diffusion equation types
-#[repr(C)]
+#[repr(u32)]
 #[derive(Clone, Copy, Debug, PartialEq)]
 pub enum FluxFn {
     /// Quadratic flux function
@@ -486,7 +486,7 @@ pub enum FluxFn {
 }
 
 /// topk function ordering
-#[repr(C)]
+#[repr(u32)]
 #[derive(Clone, Copy, Debug, PartialEq)]
 pub enum TopkFn {
     /// Top k min values
diff --git a/src/image/mod.rs b/src/image/mod.rs
index 7decdac1..1d69f7de 100644
--- a/src/image/mod.rs
+++ b/src/image/mod.rs
@@ -7,7 +7,7 @@ use error::HANDLE_ERROR;
 use util::{AfArray, DimT, MutAfArray};
 use util::{FloatingPoint, HasAfEnum, RealNumber, ImageNativeType, ImageFilterType};
 use util::{RealFloating, EdgeComputable, MomentsComputable, GrayRGBConvertible};
-use self::libc::{uint8_t, c_uint, c_int, c_float, c_double, c_char};
+use self::libc::{c_uint, c_int, c_float, c_double, c_char};
 use std::ffi::CString;
 
 // unused functions from image.h header
@@ -17,7 +17,7 @@ use std::ffi::CString;
 
 #[allow(dead_code)]
 extern {
-    fn af_cast(out: MutAfArray, arr: AfArray, aftype: uint8_t) -> c_int;
+    fn af_cast(out: MutAfArray, arr: AfArray, aftype: c_uint) -> c_int;
     fn af_gradient(dx: MutAfArray, dy: MutAfArray, arr: AfArray) -> c_int;
     fn af_load_image(out: MutAfArray, filename: *const c_char, iscolor: c_int) -> c_int;
     fn af_save_image(filename: *const c_char, input: AfArray) -> c_int;
@@ -25,22 +25,22 @@ extern {
     fn af_save_image_native(filename: *const c_char, input: AfArray) -> c_int;
 
     fn af_resize(out: MutAfArray, input: AfArray,
-                 odim0: DimT, odim1: DimT, method: uint8_t) -> c_int;
+                 odim0: DimT, odim1: DimT, method: c_uint) -> c_int;
 
     fn af_transform(out: MutAfArray, input: AfArray, trans: AfArray,
-                    odim0: DimT, odim1: DimT, method: uint8_t, is_inverse: c_int) -> c_int;
+                    odim0: DimT, odim1: DimT, method: c_uint, is_inverse: c_int) -> c_int;
 
     fn af_rotate(out: MutAfArray, input: AfArray, theta: c_float, crop: c_int,
-                 method: uint8_t) -> c_int;
+                 method: c_uint) -> c_int;
 
     fn af_translate(out: MutAfArray, input: AfArray, trans0: c_float, trans1: c_float,
-                    odim0: DimT, odim1: DimT, method: uint8_t) -> c_int;
+                    odim0: DimT, odim1: DimT, method: c_uint) -> c_int;
 
     fn af_scale(out: MutAfArray, input: AfArray, scale0: c_float, scale1: c_float,
-                odim0: DimT, odim1: DimT, method: uint8_t) -> c_int;
+                odim0: DimT, odim1: DimT, method: c_uint) -> c_int;
 
     fn af_skew(out: MutAfArray, input: AfArray, skew0: c_float, skew1: c_float,
-               odim0: DimT, odim1: DimT, method: uint8_t, is_inverse: c_int) -> c_int;
+               odim0: DimT, odim1: DimT, method: c_uint, is_inverse: c_int) -> c_int;
 
     fn af_histogram(out: MutAfArray, input: AfArray, nbins: c_uint,
                     minval: c_double, maxval: c_double) -> c_int;
@@ -49,7 +49,7 @@ extern {
     fn af_dilate3(out: MutAfArray, input: AfArray, mask: AfArray) -> c_int;
     fn af_erode(out: MutAfArray, input: AfArray, mask: AfArray) -> c_int;
     fn af_erode3(out: MutAfArray, input: AfArray, mask: AfArray) -> c_int;
-    fn af_regions(out: MutAfArray, input: AfArray, conn: uint8_t, aftype: uint8_t) -> c_int;
+    fn af_regions(out: MutAfArray, input: AfArray, conn: c_uint, aftype: c_uint) -> c_int;
     fn af_sobel_operator(dx: MutAfArray, dy: MutAfArray, i: AfArray, ksize: c_uint) -> c_int;
     fn af_rgb2gray(out: MutAfArray, input: AfArray, r: c_float, g: c_float, b: c_float) -> c_int;
     fn af_gray2rgb(out: MutAfArray, input: AfArray, r: c_float, g: c_float, b: c_float) -> c_int;
@@ -64,21 +64,21 @@ extern {
                      ch_sig: c_float, iter: c_uint, iscolor: c_int) -> c_int;
 
     fn af_medfilt(out: MutAfArray, input: AfArray,
-                  wlen: DimT, wwid: DimT, etype: uint8_t) -> c_int;
+                  wlen: DimT, wwid: DimT, etype: c_uint) -> c_int;
 
-    fn af_medfilt1(out: MutAfArray, input: AfArray, wlen: DimT, etype: uint8_t) -> c_int;
+    fn af_medfilt1(out: MutAfArray, input: AfArray, wlen: DimT, etype: c_uint) -> c_int;
 
     fn af_minfilt(out: MutAfArray, input: AfArray,
-                  wlen: DimT, wwid: DimT, etype: uint8_t) -> c_int;
+                  wlen: DimT, wwid: DimT, etype: c_uint) -> c_int;
 
     fn af_maxfilt(out: MutAfArray, input: AfArray,
-                  wlen: DimT, wwid: DimT, etype: uint8_t) -> c_int;
+                  wlen: DimT, wwid: DimT, etype: c_uint) -> c_int;
 
     fn af_gaussian_kernel(out: MutAfArray, rows: c_int, cols: c_int,
                           sigma_r: c_double, sigma_c: c_double) -> c_int;
 
     fn af_color_space(out: MutAfArray, input: AfArray,
-                      tospace: uint8_t, fromspace: uint8_t) -> c_int;
+                      tospace: c_uint, fromspace: c_uint) -> c_int;
 
     fn af_unwrap(out: MutAfArray, input: AfArray, wx: DimT, wy: DimT, sx: DimT, sy: DimT,
                  px: DimT, py: DimT, is_column: c_int) -> c_int;
@@ -162,7 +162,7 @@ pub fn load_image<T>(filename: String, is_color: bool) -> Array<T>
         let mut temp: i64 = 0;
         let err1 = af_load_image(&mut temp as MutAfArray, cstr_param.as_ptr(), is_color as c_int);
         HANDLE_ERROR(AfError::from(err1));
-        let err2 = af_cast(&mut img as MutAfArray, temp as AfArray, trgt_type as uint8_t);
+        let err2 = af_cast(&mut img as MutAfArray, temp as AfArray, trgt_type as c_uint);
         HANDLE_ERROR(AfError::from(err2));
     }
     img.into()
@@ -200,7 +200,7 @@ pub fn load_image_native<T>(filename: String) -> Array<T>
         let mut temp: i64 = 0;
         let err1 = af_load_image_native(&mut temp as MutAfArray, cstr_param.as_ptr());
         HANDLE_ERROR(AfError::from(err1));
-        let err2 = af_cast(&mut img as MutAfArray, temp as AfArray, trgt_type as uint8_t);
+        let err2 = af_cast(&mut img as MutAfArray, temp as AfArray, trgt_type as c_uint);
         HANDLE_ERROR(AfError::from(err2));
     }
     img.into()
@@ -283,7 +283,7 @@ pub fn resize<T:HasAfEnum>(input: &Array<T>,
     let mut temp: i64 = 0;
     unsafe {
         let err_val = af_resize(&mut temp as MutAfArray, input.get() as AfArray,
-                                odim0 as DimT, odim1 as DimT, method as uint8_t);
+                                odim0 as DimT, odim1 as DimT, method as c_uint);
         HANDLE_ERROR(AfError::from(err_val));
     }
     temp.into()
@@ -327,7 +327,7 @@ pub fn transform<T:HasAfEnum>(input: &Array<T>, trans: &Array<f32>,
         let err_val = af_transform(&mut temp as MutAfArray,
                                    input.get() as AfArray, trans.get() as AfArray,
                                    odim0 as DimT, odim1 as DimT,
-                                   method as uint8_t, is_inverse as c_int);
+                                   method as c_uint, is_inverse as c_int);
         HANDLE_ERROR(AfError::from(err_val));
     }
     temp.into()
@@ -368,7 +368,7 @@ pub fn rotate<T:HasAfEnum>(input: &Array<T>, theta: f64, crop: bool,
     let mut temp: i64 = 0;
     unsafe {
         let err_val = af_rotate(&mut temp as MutAfArray, input.get() as AfArray,
-                                theta as c_float, crop as c_int, method as uint8_t);
+                                theta as c_float, crop as c_int, method as c_uint);
         HANDLE_ERROR(AfError::from(err_val));
     }
     temp.into()
@@ -410,7 +410,7 @@ pub fn translate<T:HasAfEnum>(input: &Array<T>, trans0: f32, trans1: f32,
                                    input.get() as AfArray,
                                    trans0 as c_float, trans1 as c_float,
                                    odim0 as DimT, odim1 as DimT,
-                                   method as uint8_t);
+                                   method as c_uint);
         HANDLE_ERROR(AfError::from(err_val));
     }
     temp.into()
@@ -443,7 +443,7 @@ pub fn scale<T:HasAfEnum>(input: &Array<T>, scale0: f32, scale1: f32,
                                input.get() as AfArray,
                                scale0 as c_float, scale1 as c_float,
                                odim0 as DimT, odim1 as DimT,
-                               method as uint8_t);
+                               method as c_uint);
         HANDLE_ERROR(AfError::from(err_val));
     }
     temp.into()
@@ -484,7 +484,7 @@ pub fn skew<T:HasAfEnum>(input: &Array<T>,
         let err_val = af_skew(&mut temp as MutAfArray, input.get() as AfArray,
                               skew0 as c_float, skew1 as c_float,
                               odim0 as DimT, odim1 as DimT,
-                              method as uint8_t, is_inverse as c_int);
+                              method as c_uint, is_inverse as c_int);
         HANDLE_ERROR(AfError::from(err_val));
     }
     temp.into()
@@ -737,7 +737,7 @@ macro_rules! filt_func_def {
             let mut temp: i64 = 0;
             unsafe {
                 let err_val = $ffi_name(&mut temp as MutAfArray, input.get() as AfArray,
-                                        wlen as DimT, wwid as DimT, etype as uint8_t);
+                                        wlen as DimT, wwid as DimT, etype as c_uint);
                 HANDLE_ERROR(AfError::from(err_val));
             }
             temp.into()
@@ -825,7 +825,7 @@ pub fn color_space<T>(input: &Array<T>,
     let mut temp: i64 = 0;
     unsafe {
         let err_val = af_color_space(&mut temp as MutAfArray, input.get() as AfArray,
-                                     tospace as uint8_t, fromspace as uint8_t);
+                                     tospace as c_uint, fromspace as c_uint);
         HANDLE_ERROR(AfError::from(err_val));
     }
     temp.into()
@@ -856,7 +856,7 @@ pub fn regions<OutType>(input: &Array<bool>, conn: Connectivity) -> Array<OutTyp
     let mut temp: i64 = 0;
     unsafe {
         let err_val = af_regions(&mut temp as MutAfArray, input.get() as AfArray,
-                                 conn as uint8_t, otype as uint8_t);
+                                 conn as c_uint, otype as c_uint);
         HANDLE_ERROR(AfError::from(err_val));
     }
     temp.into()
@@ -1291,7 +1291,7 @@ pub fn medfilt1<T>(input: &Array<T>, wlen: u64, etype: BorderType) -> Array<T>
     let mut temp: i64 = 0;
     unsafe {
         let err_val = af_medfilt1(&mut temp as MutAfArray, input.get() as AfArray,
-                                  wlen as DimT, etype as uint8_t);
+                                  wlen as DimT, etype as c_uint);
         HANDLE_ERROR(AfError::from(err_val));
     }
     temp.into()
diff --git a/src/lapack/mod.rs b/src/lapack/mod.rs
index e4849877..62889d40 100644
--- a/src/lapack/mod.rs
+++ b/src/lapack/mod.rs
@@ -5,7 +5,7 @@ use defines::{AfError, MatProp, NormType};
 use error::HANDLE_ERROR;
 use util::{AfArray, MutAfArray, MutDouble, to_u32};
 use util::{FloatingPoint, HasAfEnum};
-use self::libc::{uint8_t, c_int, c_uint, c_double};
+use self::libc::{c_int, c_uint, c_double};
 
 #[allow(dead_code)]
 extern {
@@ -22,7 +22,7 @@ extern {
     fn af_inverse(out: MutAfArray, input: AfArray, options: c_uint) -> c_int;
     fn af_rank(rank: *mut c_uint, input: AfArray, tol: c_double) -> c_int;
     fn af_det(det_real: MutDouble, det_imag: MutDouble, input: AfArray) -> c_int;
-    fn af_norm(out: MutDouble, input: AfArray, ntype: uint8_t, p: c_double, q: c_double) -> c_int;
+    fn af_norm(out: MutDouble, input: AfArray, ntype: c_uint, p: c_double, q: c_double) -> c_int;
     fn af_is_lapack_available(out: *mut c_int) -> c_int;
 }
 
@@ -416,7 +416,7 @@ pub fn norm<T>(input: &Array<T>, ntype: NormType, p: f64, q: f64) -> f64
     let mut out: f64 = 0.0;
     unsafe {
         let err_val = af_norm(&mut out as MutDouble, input.get() as AfArray,
-                              ntype as uint8_t,
+                              ntype as c_uint,
                               p as c_double, q as c_double);
         HANDLE_ERROR(AfError::from(err_val));
     }
diff --git a/src/random/mod.rs b/src/random/mod.rs
index 80d61ca4..7159e90a 100644
--- a/src/random/mod.rs
+++ b/src/random/mod.rs
@@ -4,7 +4,7 @@ use array::Array;
 use dim4::Dim4;
 use defines::{AfError, RandomEngineType};
 use error::HANDLE_ERROR;
-use self::libc::{uint8_t, c_int, c_uint};
+use self::libc::{c_int, c_uint};
 use util::{FloatingPoint, HasAfEnum};
 use util::{DimT, MutAfArray, MutRandEngine, RandEngine, Uintl};
 
@@ -13,24 +13,24 @@ extern {
     fn af_set_seed(seed: Uintl) -> c_int;
     fn af_get_seed(seed: *mut Uintl) -> c_int;
 
-    fn af_randu(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: uint8_t) -> c_int;
-    fn af_randn(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: uint8_t) -> c_int;
+    fn af_randu(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: c_uint) -> c_int;
+    fn af_randn(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: c_uint) -> c_int;
 
-    fn af_create_random_engine(engine: MutRandEngine, rtype: uint8_t, seed: Uintl) -> c_int;
+    fn af_create_random_engine(engine: MutRandEngine, rtype: c_uint, seed: Uintl) -> c_int;
     fn af_retain_random_engine(engine: MutRandEngine, inputEngine: RandEngine) -> c_int;
-    fn af_random_engine_set_type(engine: MutRandEngine, rtpye: uint8_t) -> c_int;
-    fn af_random_engine_get_type(rtype: *mut uint8_t, engine: RandEngine) -> c_int;
+    fn af_random_engine_set_type(engine: MutRandEngine, rtpye: c_uint) -> c_int;
+    fn af_random_engine_get_type(rtype: *mut c_uint, engine: RandEngine) -> c_int;
     fn af_random_engine_set_seed(engine: MutRandEngine, seed: Uintl) -> c_int;
     fn af_random_engine_get_seed(seed: *mut Uintl, engine: RandEngine) -> c_int;
     fn af_release_random_engine(engine: RandEngine) -> c_int;
 
     fn af_get_default_random_engine(engine: MutRandEngine) -> c_int;
-    fn af_set_default_random_engine_type(rtype: uint8_t) -> c_int;
+    fn af_set_default_random_engine_type(rtype: c_uint) -> c_int;
 
     fn af_random_uniform(out: MutAfArray, ndims: c_uint, dims: *const DimT,
-                         aftype: uint8_t, engine: RandEngine) -> c_int;
+                         aftype: c_uint, engine: RandEngine) -> c_int;
     fn af_random_normal(out: MutAfArray, ndims: c_uint, dims: *const DimT,
-                        aftype: uint8_t, engine: RandEngine) -> c_int;
+                        aftype: c_uint, engine: RandEngine) -> c_int;
 }
 
 /// Set seed for random number generation
@@ -71,7 +71,7 @@ macro_rules! data_gen_def {
             unsafe {
                 let err_val = $ffi_name(&mut temp as MutAfArray,
                                         dims.ndims() as c_uint, dims.get().as_ptr() as *const DimT,
-                                        aftype as uint8_t);
+                                        aftype as c_uint);
                 HANDLE_ERROR(AfError::from(err_val));
             }
             temp.into()
@@ -112,7 +112,7 @@ impl RandomEngine {
     pub fn new(rengine: RandomEngineType, seed: Option<u64>) -> RandomEngine {
         let mut temp: i64 = 0;
         unsafe {
-            let err_val = af_create_random_engine(&mut temp as MutRandEngine, rengine as uint8_t,
+            let err_val = af_create_random_engine(&mut temp as MutRandEngine, rengine as c_uint,
                                                   match seed {Some(s) => s, None => 0} as Uintl);
             HANDLE_ERROR(AfError::from(err_val));
         }
@@ -121,20 +121,20 @@ impl RandomEngine {
 
     /// Get random engine type
     pub fn get_type(&self) -> RandomEngineType {
-        let mut temp: u8 = 0;
+        let mut temp: u32 = 0;
         unsafe {
-            let err_val = af_random_engine_get_type(&mut temp as *mut uint8_t,
+            let err_val = af_random_engine_get_type(&mut temp as *mut c_uint,
                                                     self.handle as RandEngine);
             HANDLE_ERROR(AfError::from(err_val));
         }
-        RandomEngineType::from(temp as i32)
+        RandomEngineType::from(temp)
     }
 
     /// Get random engine type
     pub fn set_type(&mut self, engine_type: RandomEngineType) {
         unsafe {
             let err_val = af_random_engine_set_type(&mut self.handle as MutRandEngine,
-                                                    engine_type as uint8_t);
+                                                    engine_type as c_uint);
             HANDLE_ERROR(AfError::from(err_val));
         }
     }
@@ -206,7 +206,7 @@ pub fn get_default_random_engine() -> RandomEngine {
 /// - `rtype` can take one of the values of enum [RandomEngineType](./enum.RandomEngineType.html)
 pub fn set_default_random_engine_type(rtype: RandomEngineType) {
     unsafe {
-        let err_val = af_set_default_random_engine_type(rtype as uint8_t);
+        let err_val = af_set_default_random_engine_type(rtype as c_uint);
         HANDLE_ERROR(AfError::from(err_val));
     }
 }
@@ -228,7 +228,7 @@ where T: HasAfEnum {
     unsafe {
         let err_val = af_random_uniform(&mut temp as MutAfArray,
                                         dims.ndims() as c_uint, dims.get().as_ptr() as *const DimT,
-                                        aftype as uint8_t, engine.get() as RandEngine);
+                                        aftype as c_uint, engine.get() as RandEngine);
         HANDLE_ERROR(AfError::from(err_val));
     }
     temp.into()
@@ -252,7 +252,7 @@ pub fn random_normal<T>(dims: Dim4, engine: &RandomEngine) -> Array<T>
     unsafe {
         let err_val = af_random_normal(&mut temp as MutAfArray,
                                        dims.ndims() as c_uint, dims.get().as_ptr() as *const DimT,
-                                       aftype as uint8_t, engine.get() as RandEngine);
+                                       aftype as c_uint, engine.get() as RandEngine);
         HANDLE_ERROR(AfError::from(err_val));
     }
     temp.into()
diff --git a/src/signal/mod.rs b/src/signal/mod.rs
index 0263ead5..67c0cfb0 100644
--- a/src/signal/mod.rs
+++ b/src/signal/mod.rs
@@ -5,7 +5,7 @@ use array::Array;
 use defines::{AfError, ConvDomain, ConvMode, InterpType};
 use error::HANDLE_ERROR;
 use self::num::Complex;
-use self::libc::{uint8_t, c_int, c_float, c_double, c_longlong, size_t};
+use self::libc::{c_uint, c_int, c_float, c_double, c_longlong, size_t};
 use util::{ComplexFloating, FloatingPoint, HasAfEnum, RealFloating};
 use util::{AfArray, MutAfArray};
 
@@ -55,13 +55,13 @@ extern {
     fn af_fft2_c2r(out: MutAfArray, input: AfArray, nfac: c_double, is_odd: c_int) -> c_int;
     fn af_fft3_c2r(out: MutAfArray, input: AfArray, nfac: c_double, is_odd: c_int) -> c_int;
 
-    fn af_convolve1(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t, d: uint8_t) -> c_int;
-    fn af_convolve2(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t, d: uint8_t) -> c_int;
-    fn af_convolve3(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t, d: uint8_t) -> c_int;
-    fn af_convolve2_sep(o: MutAfArray, c: AfArray, r: AfArray, s: AfArray, m: uint8_t) -> c_int;
-    fn af_fft_convolve1(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t) -> c_int;
-    fn af_fft_convolve2(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t) -> c_int;
-    fn af_fft_convolve3(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t) -> c_int;
+    fn af_convolve1(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint, d: c_uint) -> c_int;
+    fn af_convolve2(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint, d: c_uint) -> c_int;
+    fn af_convolve3(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint, d: c_uint) -> c_int;
+    fn af_convolve2_sep(o: MutAfArray, c: AfArray, r: AfArray, s: AfArray, m: c_uint) -> c_int;
+    fn af_fft_convolve1(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint) -> c_int;
+    fn af_fft_convolve2(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint) -> c_int;
+    fn af_fft_convolve3(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint) -> c_int;
     fn af_fir(out: MutAfArray, b: AfArray, x: AfArray) -> c_int;
     fn af_iir(out: MutAfArray, b: AfArray, a: AfArray, x: AfArray) -> c_int;
 }
@@ -337,7 +337,7 @@ macro_rules! conv_func_def {
             unsafe {
                 let err_val = $ffi_name(&mut temp as MutAfArray,
                                         signal.get() as AfArray, filter.get() as AfArray,
-                                        mode as uint8_t, domain as uint8_t);
+                                        mode as c_uint, domain as c_uint);
                 HANDLE_ERROR(AfError::from(err_val));
             }
             temp.into()
@@ -371,7 +371,7 @@ pub fn convolve2_sep<T, F>(cfilt: &Array<F>, rfilt: &Array<F>, signal: &Array<T>
     unsafe {
         let err_val = af_convolve2_sep(&mut temp as MutAfArray,
                                        cfilt.get() as AfArray, rfilt.get() as AfArray,
-                                       signal.get() as AfArray, mode as uint8_t);
+                                       signal.get() as AfArray, mode as c_uint);
         HANDLE_ERROR(AfError::from(err_val));
     }
     temp.into()
@@ -400,7 +400,7 @@ macro_rules! fft_conv_func_def {
             let mut temp: i64 = 0;
             unsafe {
                 let err_val = $ffi_name(&mut temp as MutAfArray, signal.get() as AfArray,
-                                        filter.get() as AfArray, mode as uint8_t);
+                                        filter.get() as AfArray, mode as c_uint);
                 HANDLE_ERROR(AfError::from(err_val));
             }
             temp.into()
diff --git a/src/sparse/mod.rs b/src/sparse/mod.rs
index d3ea87f1..5052c5f9 100644
--- a/src/sparse/mod.rs
+++ b/src/sparse/mod.rs
@@ -3,26 +3,26 @@ extern crate libc;
 use array::Array;
 use defines::{AfError, SparseFormat};
 use error::HANDLE_ERROR;
-use self::libc::{uint8_t, c_void, c_int};
+use self::libc::{c_uint, c_void, c_int};
 use util::{AfArray, DimT, MutAfArray, MutDimT};
 use util::{FloatingPoint, HasAfEnum};
 
 #[allow(dead_code)]
 extern {
     fn af_create_sparse_array(out: MutAfArray, nRows: DimT, nCols: DimT, vals: AfArray,
-                              rowIdx: AfArray, colIdx: AfArray, stype: uint8_t) -> c_int;
+                              rowIdx: AfArray, colIdx: AfArray, stype: c_uint) -> c_int;
 
     fn af_create_sparse_array_from_ptr(out: MutAfArray, nRows: DimT, nCols: DimT, nNZ: DimT,
                                        values: *const c_void, rowIdx: *const c_int, colIdx: *const c_int,
-                                       aftype: uint8_t, stype: uint8_t, src: uint8_t) -> c_int;
+                                       aftype: c_uint, stype: c_uint, src: c_uint) -> c_int;
 
-    fn af_create_sparse_array_from_dense(out: MutAfArray, dense: AfArray, stype: uint8_t) -> c_int;
+    fn af_create_sparse_array_from_dense(out: MutAfArray, dense: AfArray, stype: c_uint) -> c_int;
 
-    fn af_sparse_convert_to(out: MutAfArray, input: AfArray, dstStrge: uint8_t) -> c_int;
+    fn af_sparse_convert_to(out: MutAfArray, input: AfArray, dstStrge: c_uint) -> c_int;
 
     fn af_sparse_to_dense(out: MutAfArray, sparse: AfArray) -> c_int;
 
-    fn af_sparse_get_info(vals: MutAfArray, rIdx: MutAfArray, cIdx: MutAfArray, stype: *mut uint8_t,
+    fn af_sparse_get_info(vals: MutAfArray, rIdx: MutAfArray, cIdx: MutAfArray, stype: *mut c_uint,
                           input: AfArray) -> c_int;
 
     fn af_sparse_get_values(out: MutAfArray, input: AfArray) -> c_int;
@@ -33,7 +33,7 @@ extern {
 
     fn af_sparse_get_nnz(out: MutDimT, input: AfArray) -> c_int;
 
-    fn af_sparse_get_storage(out: *mut uint8_t, input: AfArray) -> c_int;
+    fn af_sparse_get_storage(out: *mut c_uint, input: AfArray) -> c_int;
 }
 
 /// Create sprase matrix from arrays
@@ -69,7 +69,7 @@ pub fn sparse<T>(rows: u64, cols: u64,
     unsafe {
         let err_val = af_create_sparse_array(&mut temp as MutAfArray, rows as DimT, cols as DimT,
                                              values.get() as AfArray, row_indices.get() as AfArray,
-                                             col_indices.get() as AfArray, format as uint8_t);
+                                             col_indices.get() as AfArray, format as c_uint);
         HANDLE_ERROR(AfError::from(err_val));
     }
     temp.into()
@@ -112,7 +112,7 @@ pub fn sparse_from_host<T>(rows: u64, cols: u64, nzz: u64,
                                                       values.as_ptr() as *const c_void,
                                                       row_indices.as_ptr() as *const c_int,
                                                       col_indices.as_ptr() as *const c_int,
-                                                      aftype as uint8_t, format as uint8_t, 1);
+                                                      aftype as c_uint, format as c_uint, 1);
         HANDLE_ERROR(AfError::from(err_val));
     }
     temp.into()
@@ -134,7 +134,7 @@ pub fn sparse_from_dense<T>(dense: &Array<T>, format: SparseFormat) -> Array<T>
     let mut temp : i64 = 0;
     unsafe {
         let err_val = af_create_sparse_array_from_dense(&mut temp as MutAfArray, dense.get() as AfArray,
-                                                        format as uint8_t);
+                                                        format as c_uint);
         HANDLE_ERROR(AfError::from(err_val));
     }
     temp.into()
@@ -157,7 +157,7 @@ pub fn sparse_convert_to<T>(input: &Array<T>, format: SparseFormat) -> Array<T>
     unsafe {
         let err_val = af_sparse_convert_to(&mut temp as MutAfArray,
                                            input.get() as AfArray,
-                                           format as uint8_t);
+                                           format as c_uint);
         HANDLE_ERROR(AfError::from(err_val));
     }
     temp.into()
@@ -196,17 +196,17 @@ pub fn sparse_to_dense<T>(input: &Array<T>) -> Array<T>
 pub fn sparse_get_info<T>(input: &Array<T>) -> (Array<T>, Array<i32>, Array<i32>, SparseFormat)
     where T: HasAfEnum + FloatingPoint
 {
-    let mut val : i64 = 0;
-    let mut row : i64 = 0;
-    let mut col : i64 = 0;
-    let mut stype : u8 = 0;
+    let mut val  : i64 = 0;
+    let mut row  : i64 = 0;
+    let mut col  : i64 = 0;
+    let mut stype: u32 = 0;
     unsafe {
         let err_val = af_sparse_get_info(&mut val as MutAfArray, &mut row as MutAfArray,
-                                         &mut col as MutAfArray, &mut stype as *mut uint8_t,
+                                         &mut col as MutAfArray, &mut stype as *mut c_uint,
                                          input.get() as AfArray);
         HANDLE_ERROR(AfError::from(err_val));
     }
-    (val.into(), row.into(), col.into(), SparseFormat::from(stype as i32))
+    (val.into(), row.into(), col.into(), SparseFormat::from(stype))
 }
 
 /// Get values of sparse Array
@@ -297,10 +297,10 @@ pub fn sparse_get_nnz<T:HasAfEnum>(input: &Array<T>) -> i64 {
 ///
 /// Sparse array format
 pub fn sparse_get_format<T:HasAfEnum>(input: &Array<T>) -> SparseFormat {
-    let mut stype : u8 = 0;
+    let mut stype : u32 = 0;
     unsafe {
-        let err_val = af_sparse_get_storage(&mut stype as *mut uint8_t, input.get() as AfArray);
+        let err_val = af_sparse_get_storage(&mut stype as *mut c_uint, input.get() as AfArray);
         HANDLE_ERROR(AfError::from(err_val));
     }
-    SparseFormat::from(stype as i32)
+    SparseFormat::from(stype)
 }
diff --git a/src/statistics/mod.rs b/src/statistics/mod.rs
index 98b1461c..f9d1c3d4 100644
--- a/src/statistics/mod.rs
+++ b/src/statistics/mod.rs
@@ -3,7 +3,7 @@ extern crate libc;
 use array::Array;
 use defines::{AfError, TopkFn};
 use error::HANDLE_ERROR;
-use self::libc::{c_int};
+use self::libc::{c_int, c_uint};
 use util::{AfArray, DimT, MutAfArray, MutDouble};
 use util::{RealNumber, CovarianceComputable};
 use util::{HasAfEnum, MedianComputable, RealFloating};
@@ -30,7 +30,7 @@ extern {
 
     fn af_corrcoef(real: MutDouble, imag: MutDouble, X: AfArray, Y: AfArray) -> c_int;
     fn af_topk(vals: MutAfArray, idxs: MutAfArray, arr: AfArray, k: c_int,
-               dim: c_int, order: c_int) -> c_int;
+               dim: c_int, order: c_uint) -> c_int;
 }
 
 /// Find the median along a given dimension
@@ -336,7 +336,7 @@ pub fn topk<T>(input: &Array<T>, k: u32, dim: i32, order: TopkFn) -> (Array<T>,
     unsafe {
         let err_val = af_topk(&mut t0 as MutAfArray, &mut t1 as MutAfArray,
                               input.get() as AfArray, k as c_int, dim as c_int,
-                              order as c_int);
+                              order as c_uint);
         HANDLE_ERROR(AfError::from(err_val));
     }
     (t0.into(), t1.into())
diff --git a/src/util.rs b/src/util.rs
index d60abdf6..863196fb 100644
--- a/src/util.rs
+++ b/src/util.rs
@@ -7,7 +7,7 @@ use error::HANDLE_ERROR;
 use std::mem;
 use self::num::Complex;
 use num::Zero;
-use self::libc::{uint8_t, c_int, size_t, c_void};
+use self::libc::{c_uint, c_int, size_t, c_void};
 
 pub type AfArray       = self::libc::c_longlong;
 pub type AfIndex       = self::libc::c_longlong;
@@ -32,7 +32,7 @@ pub type WndHandle     = self::libc::c_ulonglong;
 
 #[allow(dead_code)]
 extern {
-    fn af_get_size_of(size: *mut size_t, aftype: uint8_t) -> c_int;
+    fn af_get_size_of(size: *mut size_t, aftype: c_uint) -> c_int;
 
     fn af_alloc_host(ptr: *mut *const c_void, bytes: DimT) -> c_int;
     fn af_free_host(ptr: *mut c_void) -> c_int;
@@ -42,7 +42,7 @@ extern {
 pub fn get_size(value: DType) -> usize {
     unsafe {
         let mut ret_val: usize = 0;
-        let err_val = af_get_size_of(&mut ret_val as *mut size_t, value as uint8_t);
+        let err_val = af_get_size_of(&mut ret_val as *mut size_t, value as c_uint);
         HANDLE_ERROR(AfError::from(err_val));
         ret_val
     }
@@ -75,37 +75,37 @@ impl From<i32> for AfError {
     }
 }
 
-impl From<i32> for DType {
-    fn from(t: i32) -> DType {
-        assert!(DType::F32 as i32 <= t && t <= DType::U64 as i32);
+impl From<u32> for DType {
+    fn from(t: u32) -> DType {
+        assert!(DType::F32 as u32 <= t && t <= DType::U64 as u32);
         unsafe { mem::transmute(t) }
     }
 }
 
-impl From<i32> for InterpType {
-    fn from(t: i32) -> InterpType {
-        assert!(InterpType::NEAREST as i32 <= t && t <= InterpType::BICUBIC_SPLINE as i32);
+impl From<u32> for InterpType {
+    fn from(t: u32) -> InterpType {
+        assert!(InterpType::NEAREST as u32 <= t && t <= InterpType::BICUBIC_SPLINE as u32);
         unsafe { mem::transmute(t) }
     }
 }
 
-impl From<i32> for ConvMode {
-    fn from(t: i32) -> ConvMode {
-        assert!(ConvMode::DEFAULT as i32 <= t && t <= ConvMode::EXPAND as i32);
+impl From<u32> for ConvMode {
+    fn from(t: u32) -> ConvMode {
+        assert!(ConvMode::DEFAULT as u32 <= t && t <= ConvMode::EXPAND as u32);
         unsafe { mem::transmute(t) }
     }
 }
 
-impl From<i32> for ConvDomain {
-    fn from(t: i32) -> ConvDomain {
-        assert!(ConvDomain::AUTO as i32 <= t && t <= ConvDomain::FREQUENCY as i32);
+impl From<u32> for ConvDomain {
+    fn from(t: u32) -> ConvDomain {
+        assert!(ConvDomain::AUTO as u32 <= t && t <= ConvDomain::FREQUENCY as u32);
         unsafe { mem::transmute(t) }
     }
 }
 
-impl From<i32> for MatchType {
-    fn from(t: i32) -> MatchType {
-        assert!(MatchType::SAD as i32 <= t && t <= MatchType::SHD as i32);
+impl From<u32> for MatchType {
+    fn from(t: u32) -> MatchType {
+        assert!(MatchType::SAD as u32 <= t && t <= MatchType::SHD as u32);
         unsafe { mem::transmute(t) }
     }
 }
@@ -126,9 +126,9 @@ pub fn to_u32(t: MatProp) -> u32 {
     }
 }
 
-impl From<i32> for ColorMap {
-    fn from(t: i32) -> ColorMap {
-        assert!(ColorMap::DEFAULT as i32 <= t && t <= ColorMap::BLUE as i32);
+impl From<u32> for ColorMap {
+    fn from(t: u32) -> ColorMap {
+        assert!(ColorMap::DEFAULT as u32 <= t && t <= ColorMap::BLUE as u32);
         unsafe { mem::transmute(t) }
     }
 }
@@ -357,23 +357,23 @@ impl HasAfEnum for u64  {
     fn get_af_dtype() -> DType { DType::U64 }
 }
 
-impl From<i32> for SparseFormat {
-    fn from(t: i32) -> SparseFormat {
-        assert!(SparseFormat::DENSE as i32 <= t && t <= SparseFormat::COO as i32);
+impl From<u32> for SparseFormat {
+    fn from(t: u32) -> SparseFormat {
+        assert!(SparseFormat::DENSE as u32 <= t && t <= SparseFormat::COO as u32);
         unsafe { mem::transmute(t) }
     }
 }
 
-impl From<i32> for BinaryOp {
-    fn from(t: i32) -> BinaryOp {
-        assert!(BinaryOp::ADD as i32 <= t && t <= BinaryOp::MAX as i32);
+impl From<u32> for BinaryOp {
+    fn from(t: u32) -> BinaryOp {
+        assert!(BinaryOp::ADD as u32 <= t && t <= BinaryOp::MAX as u32);
         unsafe { mem::transmute(t) }
     }
 }
 
-impl From<i32> for RandomEngineType {
-    fn from(t: i32) -> RandomEngineType {
-        assert!(RandomEngineType::PHILOX_4X32_10 as i32 <= t && t <= RandomEngineType::MERSENNE_GP11213 as i32);
+impl From<u32> for RandomEngineType {
+    fn from(t: u32) -> RandomEngineType {
+        assert!(RandomEngineType::PHILOX_4X32_10 as u32 <= t && t <= RandomEngineType::MERSENNE_GP11213 as u32);
         unsafe { mem::transmute(t) }
     }
 }
diff --git a/src/vision/mod.rs b/src/vision/mod.rs
index f791cab2..4acbc202 100644
--- a/src/vision/mod.rs
+++ b/src/vision/mod.rs
@@ -6,7 +6,7 @@ use defines::{AfError, HomographyType, MatchType};
 use error::HANDLE_ERROR;
 use util::{AfArray, DimT, Feat, MutAfArray, MutFeat};
 use util::{HasAfEnum, RealFloating, ImageFilterType};
-use self::libc::{c_void, uint8_t, c_uint, c_int, c_float, c_double, c_longlong};
+use self::libc::{c_void, c_uint, c_int, c_float, c_double, c_longlong};
 
 // af_sift and af_gloh uses patented algorithms, so didn't add them
 // they are built using installer builds
@@ -39,7 +39,7 @@ extern {
                             dist_dim: DimT, n_dist: c_uint, dist_type: c_int) -> c_int;
 
     fn af_match_template(out: MutAfArray, search_img: AfArray, template_img: AfArray,
-                         mtype: uint8_t) -> c_int;
+                         mtype: c_uint) -> c_int;
 
     fn af_susan(feat: MutFeat, i: AfArray, r: c_uint, d: c_float, g: c_float, f: c_float, e: c_uint) -> c_int;
 
@@ -405,7 +405,7 @@ pub fn match_template<T>(search_img: &Array<T>,
     unsafe {
         let err_val = af_match_template(&mut temp as MutAfArray,
                           search_img.get() as AfArray, template_img.get() as AfArray,
-                          mtype as uint8_t);
+                          mtype as c_uint);
         HANDLE_ERROR(AfError::from(err_val));
     }
     temp.into()
