diff --git a/build.rs b/build.rs
index 57e9afd..1d885ba 100644
--- a/build.rs
+++ b/build.rs
@@ -6,7 +6,7 @@ fn main() {
     assert!(version().unwrap().major >= 1);
 
     // Check for a minimum version
-    if version().unwrap() >= Version::parse("1.33.0").unwrap() {
-        println!("cargo:rustc-cfg=memoffset_constant_expression");
+    if version().unwrap() >= Version::parse("1.37.0").unwrap() {
+        println!("cargo:rustc-cfg=memoffset_maybe_uninit");
     }
 }
diff --git a/src/constant_impl.rs b/src/constant_impl.rs
deleted file mode 100644
index ecd22b6..0000000
--- a/src/constant_impl.rs
+++ /dev/null
@@ -1,13 +0,0 @@
-// A helper to get a const fn version of size_of_val
-#[doc(hidden)]
-pub const fn size_of<T>(_: &T) -> usize {
-    ::mem::size_of::<T>()
-}
-
-// While constant pointer transmutation isn't stable, union transmutation is
-// This hack should go away after rust-lang/rust#51910
-#[doc(hidden)]
-pub union Transmuter<T: 'static> {
-    pub ptr: &'static T,
-    pub int: usize,
-}
diff --git a/src/lib.rs b/src/lib.rs
index 72620a8..6bfc622 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -67,12 +67,8 @@
 #[doc(hidden)]
 pub use core::mem;
 
-#[cfg(memoffset_constant_expression)]
 #[doc(hidden)]
-mod constant_impl;
-
-#[cfg(memoffset_constant_expression)]
-pub use constant_impl::{size_of, Transmuter};
+pub use core::ptr;
 
 #[macro_use]
 mod offset_of;
diff --git a/src/offset_of.rs b/src/offset_of.rs
index cedd798..9a943c8 100644
--- a/src/offset_of.rs
+++ b/src/offset_of.rs
@@ -66,30 +66,30 @@
 /// }
 /// ```
 #[macro_export]
-#[cfg(memoffset_constant_expression)]
+#[cfg(memoffset_maybe_uninit)]
 macro_rules! offset_of {
-    ($parent:ty, $($field:tt)+) => (unsafe {
-        let x: &'static $parent = $crate::Transmuter::<$parent> { int: 0 }.ptr;
-        $crate::Transmuter { ptr: &x.$($field)+ }.int
+    ($parent:ty, $field:tt) => (unsafe {
+        // Create an instance of the container and calculate the offset to its
+        // field. Although we are creating references to uninitialized data this
+        // is fine since we are not dereferencing them.
+        let val = $crate::mem::MaybeUninit::<$parent>::uninitialized();
+        let &$container { $field: ref f, .. } = &*val.as_ptr();
+        #[allow(unused_unsafe)]
+        let result = unsafe { (f as *const _ as *const u8).offset_from(val.as_ptr() as *const u8) };
+        result as isize
     });
 }
 
 #[macro_export]
-#[cfg(not(memoffset_constant_expression))]
+#[cfg(not(memoffset_maybe_uninit))]
 macro_rules! offset_of {
-    ($father:ty, $($field:tt)+) => ({
-        #[allow(unused_unsafe)]
-        let root: $father = unsafe { $crate::mem::uninitialized() };
-
-        let base = &root as *const _ as usize;
-
-        // Future error: borrow of packed field requires unsafe function or block (error E0133)
+    ($parent:ty, $field:tt) => ({
+        let non_null = $crate::ptr::NonNull::<$parent>::dangling();
+        let base_ptr = unsafe { non_null.as_ref() };
         #[allow(unused_unsafe)]
-        let member =  unsafe { &root.$($field)* as *const _ as usize };
-
-        $crate::mem::forget(root);
-
-        member - base
+        let field_ptr = unsafe { &base_ptr.$field };
+        let offset = (field_ptr as *const _ as usize) - (base_ptr as *const _ as usize);
+        offset
     });
 }
 
@@ -109,18 +109,6 @@ mod tests {
         assert_eq!(offset_of!(Foo, c), 8);
     }
 
-    #[test]
-    fn offset_index() {
-        assert_eq!(offset_of!(Foo, b[2]), 6);
-    }
-
-    #[test]
-    #[should_panic]
-    #[allow(const_err)]
-    fn offset_index_out_of_bounds() {
-        offset_of!(Foo, b[4]);
-    }
-
     #[test]
     fn tuple_struct() {
         #[repr(C, packed)]
diff --git a/src/span_of.rs b/src/span_of.rs
index 85758b5..f19f7cc 100644
--- a/src/span_of.rs
+++ b/src/span_of.rs
@@ -267,30 +267,15 @@ mod tests {
             span_of!(Test, y..),
             offset_of!(Test, y)..mem::size_of::<Test>()
         );
-        assert_eq!(
-            span_of!(Test, y[0]..),
-            offset_of!(Test, y[0])..mem::size_of::<Test>()
-        );
+        
         assert_eq!(
             span_of!(Test, z..),
             offset_of!(Test, z)..mem::size_of::<Test>()
         );
-        assert_eq!(
-            span_of!(Test, z.foo..),
-            offset_of!(Test, z.foo)..mem::size_of::<Test>()
-        );
         assert_eq!(
             span_of!(Test, egg..),
             offset_of!(Test, egg)..mem::size_of::<Test>()
         );
-        assert_eq!(
-            span_of!(Test, egg[0]..),
-            offset_of!(Test, egg[0])..mem::size_of::<Test>()
-        );
-        assert_eq!(
-            span_of!(Test, egg[0][0]..),
-            offset_of!(Test, egg[0][0])..mem::size_of::<Test>()
-        );
         assert_eq!(
             span_of!(Test, x..y),
             offset_of!(Test, x)..offset_of!(Test, y)
@@ -299,25 +284,9 @@ mod tests {
             span_of!(Test, x..=y),
             offset_of!(Test, x)..offset_of!(Test, y) + mem::size_of::<[u8; 56]>()
         );
-        assert_eq!(
-            span_of!(Test, x..y[4]),
-            offset_of!(Test, x)..offset_of!(Test, y[4])
-        );
         assert_eq!(
             span_of!(Test, x..=y[4]),
             offset_of!(Test, x)..offset_of!(Test, y) + mem::size_of::<[u8; 5]>()
         );
-        assert_eq!(
-            span_of!(Test, x..z.foo),
-            offset_of!(Test, x)..offset_of!(Test, z.foo)
-        );
-        assert_eq!(
-            span_of!(Test, x..=z.foo),
-            offset_of!(Test, x)..offset_of!(Test, z.foo) + mem::size_of::<u32>()
-        );
-        assert_eq!(
-            span_of!(Test, egg[0][0]..egg[1][0]),
-            offset_of!(Test, egg[0][0])..offset_of!(Test, egg[1][0])
-        );
     }
 }
