diff --git a/benches/lib.rs b/benches/lib.rs
index 5b9f7a2..9d93495 100644
--- a/benches/lib.rs
+++ b/benches/lib.rs
@@ -161,11 +161,10 @@ fn init_gen(b: &mut Bencher) {
     assert_eq!(g.is_done(), true);
 
     b.iter(|| {
-        let s = g.get_scope();
         let clo = clo_gen();
         // this cost about 20ns on unix and 60ns on windows
         // because windows Box::new take more time
-        g.init(move || clo(s));
+        g.scoped_init(clo);
         // this cost about 70ns
         // assert_eq!(g.next(), Some(0));
     });
diff --git a/src/gen_impl.rs b/src/gen_impl.rs
index 06c440f..9623671 100644
--- a/src/gen_impl.rs
+++ b/src/gen_impl.rs
@@ -57,8 +57,7 @@ impl<A> Gn<A> {
         A: 'a,
     {
         let mut g = GeneratorImpl::<A, T>::new(size);
-        let scope = g.get_scope();
-        g.init(move || f(scope));
+        g.scoped_init(f);
         g
     }
 }
@@ -123,9 +122,15 @@ impl<'a, A, T> GeneratorImpl<'a, A, T> {
         self.context.regs.prefetch();
     }
 
-    /// get the scope object
-    pub fn get_scope(&mut self) -> Scope<A, T> {
-        Scope::new(&mut self.para, &mut self.ret)
+    /// init a heap based generator with scoped closure
+    pub fn scoped_init<F: FnOnce(Scope<'a, A, T>) -> T + 'a>(&mut self, f: F)
+    where
+        T: 'a,
+        A: 'a,
+    {
+        use std::mem::transmute;
+        let scope = unsafe { transmute(Scope::new(&mut self.para, &mut self.ret)) };
+        self.init(move || f(scope));
     }
 
     /// init a heap based generator
diff --git a/src/scope.rs b/src/scope.rs
index 6d1f17d..998b9e9 100644
--- a/src/scope.rs
+++ b/src/scope.rs
@@ -11,22 +11,21 @@ use yield_::raw_yield_now;
 /// passed in scope tpye
 /// it not use the context to pass data, but keep it's own data ref
 /// this struct provide both compile type info and runtime data
-pub struct Scope<A, T> {
-    para: *mut Option<A>,
-    ret: *mut Option<T>,
+pub struct Scope<'a, A, T> {
+    para: &'a mut Option<A>,
+    ret: &'a mut Option<T>,
 }
 
-impl<A, T> Scope<A, T> {
+impl<'a, A, T> Scope<'a, A, T> {
     /// create a new scope object
-    pub fn new(para: *mut Option<A>, ret: *mut Option<T>) -> Self {
+    pub(crate) fn new(para: &'a mut Option<A>, ret: &'a mut Option<T>) -> Self {
         Scope { para, ret }
     }
 
     /// set current generator return value
     #[inline]
     fn set_ret(&mut self, v: T) {
-        let ret = unsafe { &mut *self.ret };
-        *ret = Some(v);
+        *self.ret = Some(v);
     }
 
     /// raw yiled without catch passed in para
@@ -58,8 +57,7 @@ impl<A, T> Scope<A, T> {
     /// get current generator send para
     #[inline]
     pub fn get_yield(&mut self) -> Option<A> {
-        let para = unsafe { &mut *self.para };
-        para.take()
+        self.para.take()
     }
 
     /// yiled and get the send para
diff --git a/tests/lib.rs b/tests/lib.rs
index 2cc9e05..0529304 100644
--- a/tests/lib.rs
+++ b/tests/lib.rs
@@ -446,8 +446,7 @@ fn test_re_init() {
     };
 
     let mut g = GeneratorImpl::new(0x800);
-    let s = g.get_scope();
-    g.init(|| clo()(s));
+    g.scoped_init(clo());
 
     assert_eq!(g.next(), Some(0));
     assert_eq!(g.next(), Some(3));
@@ -455,8 +454,7 @@ fn test_re_init() {
     assert_eq!(g.is_done(), true);
 
     // re-init generator
-    let s = g.get_scope();
-    g.init(|| clo()(s));
+    g.scoped_init(clo());
 
     assert_eq!(g.next(), Some(0));
     assert_eq!(g.next(), Some(3));
